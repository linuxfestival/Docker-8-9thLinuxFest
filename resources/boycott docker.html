<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- saved from url=(0029)http://www.boycottdocker.org/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="HTML Tidy, see www.w3.org">
<title>boycott docker</title>
<meta name="keywords" content="boycott, docker, linux, nat, ipv6, criticism, debian, btrfs, cloud, kiss, kvm, security">

<script src="chrome-extension://epckjefillidgmfmclhcbaembhpdeijg/notify_hook.js" type="text/javascript"></script><style type="text/css"></style></head>
<body>
<center>
<h1>boycott <a href="https://www.docker.com/">docker</a></h1>

<p><a href="http://www.boycottdocker.org/#whatyoucando">[what you can do]</a> <a href="http://www.boycottdocker.org/#seealso">[see also]</a></p>
</center>

<hr>
<p>What is Docker? Docker is aimed to be a helpful convenient tool
for simplifying virtual machines/containers creation and managing.
Unfortunately it brings much more annoying unexpected traps and
problems. Docker is intended to be a pile of lightweight simple
tools that rely on existing infrastructure available in operating
system, that tries to provide transparent virtualization layer for
running dockerized software above it. Actually most software has to
be heavily modified to be run under those conditions, dictated by
Docker operating environment (let's call it <i>DockerOS</i>).</p>

<p>Who uses Docker? Docker is vendor lock-in technology convenient
for, and spreaded by cloud computing corporations. It is not
helpful and easy to work with for free software developers willing
to make their software portable, easy to debug and support.</p>

<blockquote>Best features of Docker: 

<ul>
<li>- Easy to get a project to the top of HackerNews</li>

<li>- New Github stars for old ideas</li>

<li>- Has lots of Twitter followers</li>
</ul>

(<a href="https://twitter.com/hipsterhacker/status/577587054642536449">source</a>)</blockquote>

<h2>Better than VMs?</h2>

<table border="1" summary="Better that VMs controversies">
<tbody><tr>
<th>controversy</th>
<th>virtual machines</th>
<th>docker</th>
</tr>

<tr>
<td>Image sizes are very large</td>
<td>Actually an empty out-of-box <i>chroot</i> image (after <a href="https://wiki.debian.org/Debootstrap">debootstrap</a> for
example) is the same in all cases for all VMs and even for
Docker.</td>
<td>Docker has lower memory footprint, because of forcing to run
only single process per container: do not expect to to meet either
<i>SSH</i>, or <i>syslog</i>, or <i>NTP</i> client, or <i>cron</i>
daemon or any other well-known similar software in it.</td>
</tr>

<tr>
<td>VMs consume significant CPU</td>
<td>That depends on underlying technology. Hardware assisted KVM
with <a href="http://www.linux-kvm.org/page/Virtio">virtio</a>
capable operating system has exceptionally low overhead and context
switching times. You can run network hungry applications in those
environments with speeds comparable to direct hardware
excecution.</td>
<td>In some cases CPU hungry applications can benefit from
lightweight containers. But heavy IO and network usage will consume
more resources because of docker-related abstraction layers
requiring kernel and userspace context switches.<br>
 <i>Such virtualization can sometimes have the advantage of lower
memory usage and faster startup times, but at the cost of reduced
security, stability and compatibility</i> (<a href="http://iops.io/blog/docker-hype/">source</a>).</td>
</tr>

<tr>
<td>Competing VM environments don't play well with each other</td>
<td>One can run raw binary images under <a href="http://www.linux-kvm.org/page/Main_Page">KVM</a>, <a href="http://bhyve.org/">bhyve</a>, VirtualBox, <a href="http://wiki.qemu.org/Main_Page">qemu</a>, VMware and possibly
other ones without any catches at all. At least KVM, qemu, VMware
and VirtualBox are not required to be executed under GNU/Linux:
competing choices are available (<a href="http://www.freebsd.org/">FreeBSD</a> for example).</td>
<td>Docker images can be run only under dockerized <a href="http://www.gnu.org/">GNU</a>/<a href="https://www.kernel.org/">Linux</a>. Let's call it <i>DockerOS</i>.
Moreover, as a rule, you will require specific Linux-kernel version
compatible with provided images.</td>
</tr>

<tr>
<td>VMs were designed with machine operators in mind, not software
developers</td>
<td>Possibly, who knows. In the case of KVM, software developer
hardly knows if his program is running under either real hardware,
or virtual one.</td>
<td>Docker is designed with cloud computing providers in mind
exclusively. Software developers forced to vendor lock-in their
software, forced to make it workable under strict restrictions like
single process per container. Some software needs to be rewritten:
for example <a href="http://www.postfix.org/">Postfix</a> consists
of several daemons and all of them are a part of single monolithic
abstraction from software developer field of view (that is
incompatible with the docker's one).</td>
</tr>
</tbody></table>

<h2>Plays well with others?</h2>

<table border="1" summary="Plays well with others controversies">
<tbody><tr>
<th>controversy</th>
<th>in reality</th>
</tr>

<tr>
<td>Docker does not require you to buy into a particular
programming language, framework, packaging system, or configuration
language.</td>
<td>Except environment constraints, behaviour and overall
architecture. Your application has to be Docker locked-in. FreeBSD
<a href="https://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/jails.html">
Jails</a>, <a href="http://linux-vserver.org/Welcome_to_Linux-VServer.org">VServer</a>,
<a href="http://openvz.org/Main_Page">OpenVZ</a> containers are
just an isolated <i>chroot</i> with possible network stack
separation: they do not impose any specific conditions for your
software.</td>
</tr>

<tr>
<td>Is your application a Unix process? Does it use files, tcp
connections, environment variables, standard Unix streams and
command-line arguments as inputs and outputs? Then Docker can run
it.</td>
<td>My application uses UNIX domain sockets, TCP and UDP
connections without predefined port ranges (it is FTP). Also it
likes to fork and change it's process permissions, like many
daemons do. Docker won't be able to run even Postfix (or FTP
daemons): bright example of very high quality, clever, very secure
with UNIX-way in mind application.</td>
</tr>

<tr>
<td>Can your application's build be expressed as a sequence of such
commands? Then Docker can build it.</td>
<td>Like absolutely any shell script with that commands sequence.
Docker is able to run shell script? Great!</td>
</tr>
</tbody></table>

<h2>No way to escape dependency hell</h2>

<table border="1" summary="Dependency hell controversies">
<tbody><tr>
<th>we want</th>
<th>in reality</th>
</tr>

<tr>
<td>Deterministic builds.</td>
<td>Do your own, it is not docker business.</td>
</tr>

<tr>
<td>Build automation.</td>
<td>If you will run trivial shell-script, Docker can execute it.
Nothing more, nothing less.</td>
</tr>
</tbody></table>

<p>The only dependency hell Docker is trying to escape is
inter-daemons dependencies. Like that software requires specific <a href="http://www.postgresql.org/">PostgreSQL</a> version, and <a href="http://redis.io/">Redis</a> version. It does not dip into
either library or package dependencies at all. All this burden is
left to software developer. Exactly that kind of hell is likely to
be avoided.</p>

<p>In reality Docker won't help much even in that task. Software
developer wants to work, test and deploy software image that will
be run finally in production. Ideally it will be byte-by-byte copy
of it. At least one wishes ability of deterministic images
building: if underlying <a href="http://www.debian.org/">Debian</a>
packages versions are updated from time to time -- this should not
affect image/container building at all, without evident developer
intrusion.</p>

<p>All that tasks are left on developer's shoulders. <a href="https://www.gnu.org/software/guix/">Guix</a> package manager
solves them, but Docker can not be integrated with it (no API,
hooks, whatever).</p>

<h2>Debug hell</h2>

<table border="1" summary="Debug hell controversies">
<tbody><tr>
<th>we want</th>
<th>in reality</th>
</tr>

<tr>
<td>Transparency for software developer.</td>
<td>
<ul>
<li>Only available interaction is containers API, that are not
transparent at all.</li>

<li>Only single process per container architecture is
acceptable.</li>

<li><i>stdout</i> is buffered and does not behave like standard
pipes and terminals.</li>

<li>Multithreaded, forking applications are not expected to work as
you would like to.</li>

<li>Immutable code and mutable data separation dictatorship.</li>
</ul>
</td>
</tr>
</tbody></table>

<p>Do you wish to write your new application from scratch,
dockerize it at the very beginning and observe almost ready
production environment? Forget about it, do not fool yourself. You
process is isolated and you can talk with it through Docker created
layers. It won't allow deploying SSH inside it, won't allow to
create bunch of temporary files you wish to observe so much. If you
daemon is intended to be controlled through some kind of socket
with special utility for communicating with: you have to dockerize
it too. <i>Netcat</i>: dockerize it first. <i>Socat</i>,
<i>tcpdump</i>: same story again.</p>

<p><i>Docker adds an intrusive layer of complexity which makes
development, troubleshooting and debugging frustratingly difficult,
often creating more problems than it solves. It doesn't have any
benefits over deployment…</i> (<a href="http://iops.io/blog/docker-hype/">source</a>).</p>

<h2>Deployment hell</h2>

<table border="1" summary="Deployment hell controversies">
<tbody><tr>
<th>we want</th>
<th>in reality</th>
</tr>

<tr>
<td>Minimal barrier of entry for system administrators.</td>
<td>OS running Docker becomes DockerOS. It is not UNIX-like OS. All
you default standard commands like <i>ps</i>, <i>ls</i>,
<i>find</i>, <i>netstat</i>, <i>sockstat</i>, <i>tail</i> and
similar are useless here. You have to learn all that bunch of yet
another new commands with totally different behaviour.</td>
</tr>
</tbody></table>

<p>What daemons are so resource hungry? Who takes huge amount of
sockets? By whom this file descriptor is taken? Who owns that
network interface? Which daemon will answer me on that
address:port? All those questions can be answered by system
administrator at once. Because all that UNIX-like operating systems
are very similar and have identical or resembling commands. But no
sysadmin will be able to do that under DockerOS. All his knowledge
is nothing in that environment. Everything must be done using
completely different approaches and vendor (Docker) specific
tools.</p>

<p>Running VMs under an ordinary OS is nothing exceptional. Just
another process, maybe newly appeared network interface in
predefined bridge. DockerOS will thrash and rape you
<i>iptables</i> rules, network interfaces hierarchy and routing
tables. In fact you can not expect to run anything else that is
related to network on DockerOS machine. It is ok for big cloud
computing datacenters, where firewalls and routers are
external.</p>

<p><i>If your development workflow is sane, then you will already
understand that Docker is unnecessary. All of the features which it
claims to be helpful are either useless or poorly implemented, and
it's primary benefits can be easily achieved using namespaces
directly. Docker would have been a cute idea 8 years ago, but it's
pretty much useless today.</i> (<a href="http://iops.io/blog/docker-hype/">source</a>).</p>

<h2>Reliability hell</h2>

<table border="1" summary="Reliability hell controversies">
<tbody><tr>
<th>we want</th>
<th>in reality</th>
</tr>

<tr>
<td>Time proven, <a href="https://en.wikipedia.org/wiki/KISS_principle">KISS</a>.</td>
<td>
<ul>
<li>bridge, routing, <a href="https://en.wikipedia.org/wiki/Network_address_translation">NAT</a>,
userland proxies layers.</li>

<li>Event latest stable Debian distribution contains already
obsolete Linux kernel for Docker.</li>

<li><a href="https://en.wikipedia.org/wiki/Aufs">aufs</a>, <a href="https://en.wikipedia.org/wiki/Btrfs">btrfs</a>: completely new
creations, too young to discuss about and suicidal in mission
critical deployments without any doubts.</li>
</ul>
</td>
</tr>
</tbody></table>

<p>Time proven actively running for years software is a synonym of
reliability and maturity. Only that kind of software (never
bleeding edge) is used in mission critical cases. That is why
exceptionally in military fields we can see so old (but proven and
mature) Linux-kernels.</p>

<p>Another synonym of reliability is simplicity. KISS principle has
always been worked. That is why Docker tries to do its best by
making a multi-layered mess of <i>iptables</i>, <i>NAT</i>,
<i>bridges</i>, <i>cgroups</i>, <i>btrfs</i>, <i>aufs</i>,
<i>device mapper</i>, self-written TCP proxies and stack of
utilities to drive all of that.</p>

<p>You can not easily and directly access your durable non-volatile
data storage (it is separated). Do you trust rewritten <i>aufs</i>?
Can you trust <i>btrfs</i> (marked as stable only in August 2014)
at all? Moreover there is no way to control file system page caches
among containers: it is not likely aimed to be used with high IO
rate storages.</p>

<h2>Network ancient ages step back</h2>

<table border="1" summary="Network awfullness controversies">
<tbody><tr>
<th>we want</th>
<th>in reality</th>
</tr>

<tr>
<td><a href="https://en.wikipedia.org/wiki/IPv6">IPv6</a>, death to
IPv4</td>
<td>NAT, proxies, addressing scheme used in Docker is fully
incompatible with IPv6.</td>
</tr>

<tr>
<td>Death to NAT, in all cases</td>
<td>If you see DockerOS, then be sure that NAT is enabled.</td>
</tr>

<tr>
<td>High performance</td>
<td>Multiple network layers, userland context switching and NAT
will force you to forget about speed and low delays.</td>
</tr>

<tr>
<td>Leave our firewall rules alone!</td>
<td>Nope.</td>
</tr>
</tbody></table>

<p>For a long time even so hated (by UNIXmen, hackers, and so on)
Microsoft Windows Server plays well with IPv6 and suggests to build
networks exclusively with that modern superior network protocol.
iOS, Android, all modern GNU/Linux, *BSD systems work with IPv6
out-of-box well. It is beautiful and very convenient for network
administrators protocol. All software must be capable to deal with
that protocol everywhere. For datacenters particularly there is no
reason to avoid its usage internally. But we are talking about
Docker: it does not support IPv6 at all. You can not run IPv6
capable software under it: only by fully manual interaction and
configuration.</p>

<p>For ages people have hated NAT. People hate spammers and NAT
technology. This is the thing that should not been even born. It is
a dirty ugly hack ruining the Internet architecture principle. No
NAT, burn it, use IPv6, period. Unfortunately Docker use it
intensively out-of-box. It is NAT locked-in. Worse yet: Docker also
likes to use userland TCP proxy per container. At least NAT works
at kernel context level (staying very CPU hungry anyway).
Performance and response times are doomed.</p>

<p>The choice of NAT was an awful decision, but having identified
that too late, they proceeded to <a href="https://github.com/docker/docker/commit/fac0d87d00ada08309ea3b82cae69beeef637c89">
&gt;create userland</a> garbage-collected NAT clone.</p>

<h2>Security. Never heard of it</h2>

<table border="1" summary="Deployment hell controversies">
<tbody><tr>
<th>we want</th>
<th>in reality</th>
</tr>

<tr>
<td>
<ul>
<li>Repositories authentication.</li>

<li>Images authentication.</li>
</ul>
</td>
<td>No authentication at all. Just trust Docker Hub.</td>
</tr>

<tr>
<td><a href="http://www.selinuxproject.org/page/Main_Page">SELinux</a>, <a href="http://wiki.apparmor.net/index.php/Main_Page">AppArmor</a>
friendliness.</td>
<td>Docker does not deal with them at all. It is easier to say that
it is impossible.</td>
</tr>
</tbody></table>

<p>For a very long time <a href="https://gnupg.org/">PGP</a> is
used extensively for signing distribution package files. If you
trust your vendor, then cryptography will deterministically
reliably trust it's binary distributions (<a href="http://www.openbsd.org/">OpenBSD</a> has it's own package signing
tools). In Debian, <a href="http://www.ubuntu.com/">Ubuntu</a> you
have to import those signing keys first, to be able to fetch
repositories. Docker is much more simple: it does not do any either
repository or image verification at all. If there was any security
in mind, then no one will thought about using binary images from
Docker Hub, because no trust is assigned and linked to them.
Unauthenticated repositories are acceptable at intranet level at
most.</p>

<p>Docker does not know anything about either SELinux or AppArmor
<a href="https://en.wikipedia.org/wiki/Mandatory_access_control">MAC</a>
frameworks, that are mandatory in high secure grade environments.
It does not provide any helpers to work with them. That also means
cloud datacenters do not worry much about valuable consumer data:
<i>cgroups</i> isolation is good enough for them. Secure
environments? Not applicable in DockerOS.</p>

<hr>
<center>
<h2><a name="whatyoucando">What can you do</a></h2>
</center>

<ul>
<li>Do not allow to vendor lock-in yourself (you become
slave).</li>

<li>Respect yourself and write software as <b>you</b> wish to, not
the cloud computing corporations are happy to.</li>

<li>Do not forget about portability, GNU/Linux is not the only OS
in the UNIX-like world.</li>

<li>Do not destroy your beauty sexy fast IPv6 network with
awfulness injected by DockerOS.</li>

<li>Learn simple POSIX shell scipting, man!</li>

<li>Learn how to use already existing time proven mature
virtualization technologies.</li>

<li>Forget about enterprise cumbersome bloated technologies, keep
it simple, elegant and <a href="http://suckless.org/">suckless</a>!</li>

<li>Look at <a href="https://www.gnu.org/software/guix/">Guix</a>
package manager.</li>
</ul>

<hr>
<center>
<h2><a name="seealso">See also</a></h2>
</center>

<ul>
<li><a href="http://iops.io/blog/lxc-application-containers-docker-initial-thoughts/">
LXC containers are awesome, but Docker.io sucks</a></li>

<li><a href="http://iops.io/blog/docker-hype/">Lets review… Docker
(again)</a></li>

<li><a href="http://reventlov.com/advisories/using-the-docker-command-to-root-the-host">
Great example of Docker usage</a></li>

<li><a href="https://www.andreas-jung.com/contents/the-case-against-docker">Case
against Docker</a></li>

<li><a href="http://www.krisbuytaert.be/blog/docker-vs-reality-0-1">Docker vs
Reality, 0 - 1</a></li>

<li><a href="http://grep.be/blog//en/computer/Docker/">Docker is
the new hype these days</a></li>

<li><a href="http://www.vitavonni.de/blog/201503/2015031201-the-sad-state-of-sysadmin-in-the-age-of-containers.html">
The sad state of sysadmin in the age of containers</a></li>

<li><a href="http://doger.io/">wow suck container</a></li>
</ul>

<hr>
<p>You can send something to admin boycottdocker dot org.</p>

<p>Last updated: 2016-01-11 19:00.</p>



<div id="libnotify-notifications-transfer-dom-area" style="display: none;"></div></body></html>